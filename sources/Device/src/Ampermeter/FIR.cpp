// 2022/11/15 16:06:51 (c) Aleksandr Shevchenko e-mail : Sasha7b9@tut.by
#include "defines.h"
#include "Ampermeter/FIR.h"


/*
Filter type: Low Pass
Filter model: Chebyshev
Filter order: 7
Sampling Frequency: 100 KHz
Cut Frequency: 10.000000 KHz
Pass band Ripple: 0.001000 dB
Coefficents Quantization: float

Z domain Zeros
z = -1.000000 + j 0.000000
z = -1.000000 + j 0.000000
z = -1.000000 + j 0.000000
z = -1.000000 + j 0.000000
z = -1.000000 + j 0.000000
z = -1.000000 + j 0.000000
z = -1.000000 + j 0.000000

Z domain Poles
z = 0.604301 + j -0.232108
z = 0.604301 + j 0.232108
z = 0.611745 + j -0.444999
z = 0.611745 + j 0.444999
z = 0.605922 + j -0.000000
z = 0.661094 + j -0.625252
z = 0.661094 + j 0.625252
*/


int FIR::Step(int new_sample)
{
#define Ntap 31

    float FIRCoef[Ntap] = {
        -0.00576952606999899670F,
        -0.01267176935638506500F,
        -0.01306818061582011200F,
        -0.00460364723795069190F,
         0.00986103859868734350F,
         0.02237096789147109300F,
         0.02340439654322595100F,
         0.00771819179032145510F,
        -0.02039646893245402800F,
        -0.04595779397973703800F,
        -0.04836861204958659700F,
        -0.01170257435038574000F,
         0.06439813824468911000F,
         0.15975799380561748000F,
         0.23962350906975760000F,
         0.27080867329709657000F,
         0.23962350906975760000F,
         0.15975799380561748000F,
         0.06439813824468911000F,
        -0.01170257435038574000F,
        -0.04836861204958659700F,
        -0.04595779397973703800F,
        -0.02039646893245402800F,
         0.00771819179032145510F,
         0.02340439654322595100F,
         0.02237096789147109300F,
         0.00986103859868734350F,
        -0.00460364723795069190F,
        -0.01306818061582011200F,
        -0.01267176935638506500F,
        -0.00576952606999899670F
    };

    static float x[Ntap]; //input samples
    float y = 0;            //output sample
    int n;

    //shift the old samples
    for (n = Ntap - 1; n > 0; n--)
        x[n] = x[n - 1];

    //Calculate the new output
    x[0] = (float)new_sample;
    for (n = 0; n < Ntap; n++)
        y += FIRCoef[n] * x[n];

    return (int)y;
}
